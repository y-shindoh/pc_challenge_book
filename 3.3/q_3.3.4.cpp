/* -*- coding: utf-8; tab-width: 4 -*- */
/**
 * @file	q_3.3.4.cpp
 * @brief	「プログラミングコンテストチャレンジブック」の§3.2 p.168の問題の回答
 * @author	Yasutaka SHINDOH / 新堂 安孝
 * @note	see http://www.amazon.co.jp/2-ebook/dp/B00CY9256C/ .
 */

/*
  メモ:
  平方分割し各ブロックをソートした結果を別の配列Aに持つ。
  クエリに対し、完全に含まれるブロックと部分的に含まれるブロックを区別し、
  後者の全要素を別の配列Bにおいてソートする。
  完全に含まれる各ブロックと配列Bを対象にマージソートのマージ処理を行い、
  k番目の値を算出する。
  b = n^-2 とした時の計算量は以下の通り。

  - 前処理: O(n + n/b * b * log b) = O(n log b)
  - 後処理: O(k + b log b)

  これは後述の解法より計算量が多いが、メモリ占有量は2/3程度で済む。

  備考:
  書籍の解法は前処理 O(n log n)、後処理 O((n log n)^-2) のもの。
  入力全体をソートした配列A、各ブロックをソートした結果を別に持ち、
  前者に対し、二分探索する。
  クエリに対し、完全に含まれるブロックと部分的に含まれるブロックを区別し、
  前者には二分探索を、後者には線形探索を行い、
  x以下の要素の個数を算出する (xは配列Aの二分探索で注目している値)。
  この個数がkになるまでxを更新し、
  個数がkになった時の値xが解となる。
 */

#include <cstdio>

int
main()
{
	std::printf("実装は後回し。\n");

	return 0;
}
